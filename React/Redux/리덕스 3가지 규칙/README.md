# 리덕스의 3가지 규칙

리덕스에는 꼭 지켜야 할 3가지 규칙이 있다.

## 1. 하나의 애플리케이션 안에는 하나의 스토어가 있다.

하나의 애플리케이션에서는 단 한개의 스토어를 만들어서 사용해야 한다. **여러개의 스토어를 사용하는 것은 사실 가능하긴 하지만 권장되지는 않는다.** 특정 업데이트가 너무 빈번하게 일어나거나 애플리케이션의 특정 부분을 완전히 분리시키게 될 때 여러개의 스토어를 만들 수도 있다. 하지만 그렇게 하면 개발 도구를 활용하지 못하게 된다.

## 2. 상태는 읽기 전용이다.

리액트에서는 state를 업데이트 해야 할 때, setState를 사용하고, 배열을 업데이트 해야 할 때는 배열 자체를 push를 직접하지 않고, concat 같은 함수를 사용하여 기존의 배열을 수정하지 않고 새로운 배열을 만들어서 교체하는 방식으로 업데이트를 한다. 엄청 깊은 구조로 되어있는 개체를 업데이트 할 때도 마찬가지로, 기존의 객체는 건드리지 않고 Object.assign을 사용하거나 spread 연산자(…)를 사용하여 업데이트한다.

리덕스에서도 마찬가지이다. 기존의 상태는 건들이지 않고 새로운 상태를 생성하여 업데이트 해주는 방식으로 해주면, 나중에 개발자 도구를 통해서 뒤로 돌리거나 앞으로 돌리거나 할 수 있다.

**리덕스에서 불변성을 유지해야 하는 이유는 내부적으로 데이터가 변경되는 것을 감지하기 위하여 shallow equality 검사를 하기 때문**이다. 이를 통하여 객체의 변화를 감지할 때 깊숙한 안쪽까지 비교를 하는 것이 아니라 겉핥기 식으로 비교를 하여 좋은 성능을 유지할 수 있는 것이다.

## 3. 변화를 일으키는 함수, 리듀서는 순수한 함수여야 한다.

- 리듀서 함수는 이전 상태와, 액션 객체를 파라미터로 받는다.
- 이전의 상태는 절대로 건들이지 않고, 변화를 일으킨 새로운 상태 객체를 만들어서 반환한다.
- 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과값을 반환해야 한다.

3가지 사항을 주의해야 한다. **동일한 인풋이라면 언제나 동일한 아웃풋이 있어야 한다.** 하지만 일부 로직들 중에서는 실행할 때마다 다른 결과값이 나타날 수 있다. new Date(), 랜덤 숫자 생성이라던지 혹은, 네트워크에 요청을 한다던지. **이러한 작업은 순수하지 않은 작업이므로 리듀서 바깥에서 처리**해줘야 한다.
